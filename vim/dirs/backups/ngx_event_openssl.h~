
/*
 * Copyright (C) Igor Sysoev
 * Copyright (C) Nginx, Inc.
 */


#ifndef _NGX_EVENT_OPENSSL_H_INCLUDED_
#define _NGX_EVENT_OPENSSL_H_INCLUDED_


#include <ngx_config.h>
#include <ngx_core.h>

#include <openssl/ssl.h>
#include <openssl/err.h>
#include <openssl/bn.h>
#include <openssl/conf.h>
#include <openssl/crypto.h>
#include <openssl/dh.h>
#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif
#include <openssl/evp.h>
#include <openssl/hmac.h>
#ifndef OPENSSL_NO_OCSP
#include <openssl/ocsp.h>
#endif
#if (NGX_KEYLESS_SSL || NGX_KEYLESS_SERVER)
#include <openssl/ec.h>
#if OPENSSL_VERSION_NUMBER < 0x10100000L
#include <openssl/ec_lcl.h>
#endif
#endif
#if (NGX_HTTP_TAIR)
#include <ngx_etair_module.h>
#endif

#if OPENSSL_VERSION_NUMBER >= 0x10100003L
#include <openssl/bn.h>
#include <openssl/crypto.h>
#include <openssl/rand.h>
#include <openssl/rsa.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include <openssl/x509_vfy.h>
#endif

//#include <openssl/rand.h>
//#include <openssl/rsa.h>
//#include <openssl/x509.h>
//#include <openssl/x509v3.h>

#define NGX_SSL_NAME     "OpenSSL"


#if (defined LIBRESSL_VERSION_NUMBER && OPENSSL_VERSION_NUMBER == 0x20000000L)
#undef OPENSSL_VERSION_NUMBER
#define OPENSSL_VERSION_NUMBER  0x1000107fL
#endif


#if (OPENSSL_VERSION_NUMBER >= 0x10100001L)

#define ngx_ssl_version()       OpenSSL_version(OPENSSL_VERSION)

#else

#define ngx_ssl_version()       SSLeay_version(SSLEAY_VERSION)

#endif

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
#define SSL_is_server(s)        (s)->server
#endif


#define ngx_ssl_session_t       SSL_SESSION
#define ngx_ssl_conn_t          SSL


typedef struct ngx_cert {
    X509                       *cert;
    ngx_str_t                   name;
} ngx_cert_t;

 typedef struct {
    ngx_msec_t                  timeout;
    ngx_uint_t                  threshold;
    size_t                      size_lo;
    size_t                      size_hi;
} ngx_ssl_dyn_rec_t;

struct ngx_ssl_s {
    SSL_CTX                    *ctx;
    ngx_log_t                  *log;
    size_t                      buffer_size;

    RSA                        *pubkey;
#if (NGX_KEYLESS_SSL)
    EC_POINT                   *ec_point;
#endif
    ngx_cert_t                 rsa_certs[6];
    ngx_cert_t                 ecc_certs[6];
    ngx_cert_t                 dsa_certs[6];
    ngx_uint_t                 rsa_hash;	
    ngx_uint_t                 ecc_hash;	
    ngx_uint_t                 dsa_hash;	
    ngx_flag_t                 rsa_pss;

    ngx_ssl_dyn_rec_t           dyn_rec;
};


struct ngx_ssl_connection_s {
    ngx_ssl_conn_t             *connection;
    SSL_CTX                    *session_ctx;

    ngx_int_t                   last;
    ngx_buf_t                  *buf;
    size_t                      buffer_size;

    ngx_connection_handler_pt   handler;
    ngx_ssl_session_t          *session;
    ngx_connection_handler_pt   save_session;

    ngx_event_handler_pt        saved_read_handler;
    ngx_event_handler_pt        saved_write_handler;

    time_t                      handshake_sec;
    ngx_msec_t                  handshake_msec;

    void                       *lua_ctx;  /* used by 3rd-party modules */

    unsigned                    handshaked:1;
    unsigned                    renegotiation:1;
    unsigned                    buffer:1;
    unsigned                    no_wait_shutdown:1;
    unsigned                    no_send_shutdown:1;
    unsigned                    handshake_buffer_set:1;
    unsigned                    client_hello_retry:1;
    unsigned                    client_verify_enable:1; /* used for lua hotconf */

    ngx_ssl_dyn_rec_t           dyn_rec;
    ngx_msec_t                  dyn_rec_last_write;
    ngx_uint_t                  dyn_rec_records_sent;

    time_t                      keyless_sec;
    ngx_msec_t                  keyless_msec;
};


typedef struct {
    ngx_ssl_t                  *ssl;
    ngx_str_t                  *server_name;
    ngx_str_t                  *type;
    ngx_str_t                  *encrypt;
} ngx_http_ssl_pphrase_dialog_conf_t;


#if (NGX_KEYLESS_SSL || NGX_KEYLESS_SERVER)
#define T_RSA       1
#define T_ECC       2
#define T_RSA_PSS   3
#endif

#if (NGX_KEYLESS_SSL)
typedef struct ngx_ssl_keyless_connection_s  ngx_ssl_keyless_connection_t;

struct ngx_ssl_keyless_connection_s {
    ngx_connection_t           *connection;
    ngx_connection_t           *o_connection;

    ngx_int_t                   last;
    ngx_buf_t                  *buf;
    size_t                      buffer_size;

    ngx_str_t                   out;
    ngx_str_t                   decrypt_rsa;
    ngx_uint_t                  state;

    ngx_str_t                  *name;
    socklen_t                   socklen;
    struct sockaddr            *sockaddr;
    ngx_flag_t                  keepalive;
    ngx_uint_t                  keepalived;
    ngx_uint_t                  keyless_client_requests;

    ngx_flag_t                  use_ssl;

    ngx_log_t                  *log;
    void                       *conf;

    SSL                        *ssl;
    uint32_t                    id;
    uint32_t                    type;
    RSA                        *pubkey;
    EC_POINT                   *ec_point;

    void (*ssl_init_callback)(ngx_ssl_keyless_connection_t *,
                              ngx_connection_t *);
    void (*ssl_close_callback)(ngx_connection_t *);
    void (*keepalive_save_callback)(ngx_connection_t *);

    ngx_event_handler_pt        rev_handler;
    ngx_event_handler_pt        wev_handler;

    ngx_msec_t                  read_timeout;
    ngx_msec_t                  write_timeout;
    ngx_flag_t                  slbinfo_enable;

#if (NGX_KEYLESS_QUIC)
    ngx_flag_t                  quic;
    void                        *qc;
    ngx_str_t                   *sni;
    time_t                      keyless_sec;
    ngx_msec_t                  keyless_msec;
#endif
};
#endif


#define NGX_SSL_NO_SCACHE            -2
#define NGX_SSL_NONE_SCACHE          -3
#define NGX_SSL_NO_BUILTIN_SCACHE    -4
#define NGX_SSL_DFLT_BUILTIN_SCACHE  -5


#define NGX_SSL_MAX_SESSION_SIZE  16384

typedef struct ngx_ssl_sess_id_s  ngx_ssl_sess_id_t;

struct ngx_ssl_sess_id_s {
    ngx_rbtree_node_t           node;
    u_char                     *id;
    size_t                      len;
    u_char                     *session;
    ngx_queue_t                 queue;
    time_t                      expire;
#if (NGX_PTR_SIZE == 8)
    void                       *stub;
    u_char                      sess_id[32];
#endif
#if (NGX_TCP_SSLSYNC)    
    ngx_flag_t                  sync_sess;
#endif  
};


typedef struct {
    ngx_rbtree_t                session_rbtree;
    ngx_rbtree_node_t           sentinel;
    ngx_queue_t                 expire_queue;
#if (NGX_TCP_SSLSYNC)
    ngx_queue_t                 sync_queue;
    ngx_int_t                   sync_queue_num;
    ngx_int_t                   sync_enable;
#endif

#if (NGX_HTTP_SERVER_STATUS_MODULE || NGX_TCP_SSLSYNC)
    ngx_int_t                   st_new;
    ngx_int_t                   st_reused;  /* session reused count */
    ngx_int_t                   st_miss;
    ngx_int_t                   st_hit_expire;
    ngx_int_t                   st_expire;
    ngx_int_t                   st_remove;
    size_t                      st_used;
    ngx_uint_t                  st_sync;      /* count of sync session from remote */
    ngx_uint_t                  st_to_sync;   /* count of sync session to remote */
    ngx_uint_t                  st_sync_reused;   /* count of sync session */
    ngx_uint_t                  st_local;   /* count of local session */
 #endif
} ngx_ssl_session_cache_t;


#ifdef SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB

typedef struct {
    size_t                      size;
    u_char                      name[16];
    u_char                      hmac_key[32];
    u_char                      aes_key[32];
} ngx_ssl_session_ticket_key_t;

ngx_int_t ngx_ssl_lua_ffi_set_session_ticketkey(ngx_ssl_t *ssl, ngx_array_t *keys);

#endif


#define NGX_SSL_SSLv2    0x0002
#define NGX_SSL_SSLv3    0x0004
#define NGX_SSL_TLSv1    0x0008
#define NGX_SSL_TLSv1_1  0x0010
#define NGX_SSL_TLSv1_2  0x0020
#define NGX_SSL_TLSv1_3  0x0040


#define NGX_SSL_BUFFER   1
#define NGX_SSL_CLIENT   2

#define NGX_SSL_BUFSIZE  16384


ngx_int_t ngx_ssl_init(ngx_log_t *log);
ngx_int_t ngx_ssl_create(ngx_ssl_t *ssl, ngx_uint_t protocols, void *data);
ngx_int_t ngx_ssl_certificates(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_array_t *certs, ngx_array_t *keys, ngx_array_t *passwords);
ngx_int_t ngx_ssl_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_str_t *cert, ngx_str_t *key, ngx_array_t *passwords);
ngx_int_t ngx_ssl_ciphers(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *ciphers,
    ngx_uint_t prefer_server_ciphers);
ngx_int_t ngx_ssl_client_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_str_t *cert, ngx_int_t depth);
ngx_int_t ngx_ssl_trusted_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_str_t *cert, ngx_int_t depth);
ngx_int_t ngx_ssl_crl(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *crl);
ngx_int_t ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_str_t *file, ngx_str_t *responder, ngx_uint_t verify);
ngx_int_t ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_resolver_t *resolver, ngx_msec_t resolver_timeout);
RSA *ngx_ssl_rsa512_key_callback(ngx_ssl_conn_t *ssl_conn, int is_export,
    int key_length);
ngx_array_t *ngx_ssl_read_password_file(ngx_conf_t *cf, ngx_str_t *file);
ngx_int_t ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file);
ngx_int_t ngx_ssl_ecdh_curve(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *name);
ngx_int_t ngx_ssl_client_session_cache(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_uint_t enable);
ngx_int_t ngx_ssl_session_cache(ngx_ssl_t *ssl, ngx_str_t *sess_ctx,
    ssize_t builtin_session_cache, ngx_shm_zone_t *shm_zone, time_t timeout);
ngx_int_t ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_array_t *paths, ngx_array_t *keys);
ngx_int_t ngx_dyaccept_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl,
    ngx_array_t *paths);
ngx_int_t ngx_ssl_session_cache_init(ngx_shm_zone_t *shm_zone, void *data);
ngx_int_t ngx_ssl_create_connection(ngx_ssl_t *ssl, ngx_connection_t *c,
    ngx_uint_t flags);

void ngx_ssl_remove_cached_session(SSL_CTX *ssl, ngx_ssl_session_t *sess);
ngx_int_t ngx_ssl_set_session(ngx_connection_t *c, ngx_ssl_session_t *session);
ngx_ssl_session_t *ngx_ssl_get_session(ngx_connection_t *c);
ngx_ssl_session_t *ngx_ssl_get0_session(ngx_connection_t *c);
#define ngx_ssl_free_session        SSL_SESSION_free
#define ngx_ssl_get_connection(ssl_conn)                                      \
    SSL_get_ex_data(ssl_conn, ngx_ssl_connection_index)
#define ngx_ssl_get_server_conf(ssl_ctx)                                      \
    SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_server_conf_index)

#define ngx_ssl_verify_error_optional(n)                                      \
    (n == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT                              \
     || n == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN                             \
     || n == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY                     \
     || n == X509_V_ERR_CERT_UNTRUSTED                                        \
     || n == X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE)

ngx_int_t ngx_ssl_check_host(ngx_connection_t *c, ngx_str_t *name);


ngx_int_t ngx_ssl_get_protocol(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_cipher_name(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_ciphers(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_curves(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_session_id(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_session_reused(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_session_reused_type(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_server_name(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_raw_certificate(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_certificate(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_escaped_certificate(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_subject_dn(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_issuer_dn(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_subject_dn_legacy(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_issuer_dn_legacy(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_serial_number(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_fingerprint(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_client_verify(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_client_v_start(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_client_v_end(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_client_v_remain(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_handshake_time(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);
ngx_int_t ngx_ssl_get_keyless_response_time(ngx_connection_t *c, ngx_pool_t *pool,
    ngx_str_t *s);


ngx_int_t ngx_ssl_handshake(ngx_connection_t *c);
ssize_t ngx_ssl_recv(ngx_connection_t *c, u_char *buf, size_t size);
ssize_t ngx_ssl_write(ngx_connection_t *c, u_char *data, size_t size);
ssize_t ngx_ssl_recv_chain(ngx_connection_t *c, ngx_chain_t *cl, off_t limit);
ngx_chain_t *ngx_ssl_send_chain(ngx_connection_t *c, ngx_chain_t *in,
    off_t limit);
void ngx_ssl_free_buffer(ngx_connection_t *c);
ngx_int_t ngx_ssl_shutdown(ngx_connection_t *c);
void ngx_cdecl ngx_ssl_error(ngx_uint_t level, ngx_log_t *log, ngx_err_t err,
    char *fmt, ...);
void ngx_ssl_cleanup_ctx(void *data);

void ngx_ssl_reset_tlsver(ngx_connection_t *c, ngx_ssl_conn_t *ssl);

#if (NGX_KEYLESS_SSL)
ngx_int_t ngx_ssl_certificates_keyless(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *certs,
    ngx_array_t *keys, ngx_http_ssl_pphrase_dialog_conf_t *dialog, void *sscf,
    ngx_uint_t keyless);
ngx_int_t ngx_ssl_certificate_keyless(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
    ngx_str_t *key, ngx_http_ssl_pphrase_dialog_conf_t *dialog, void *sscf,
    ngx_uint_t keyless);
ngx_int_t ngx_ssl_keyless_connect(ngx_ssl_keyless_connection_t *skc);
void ngx_ssl_keyless_send(ngx_ssl_keyless_connection_t *skc);
ngx_int_t ngx_ssl_keyless_build_request(ngx_ssl_keyless_connection_t *skc,
    void *data, unsigned long len);
void ngx_ssl_keyless_send_handler(ngx_event_t *ev);
void ngx_ssl_keyless_recv_handler(ngx_event_t *ev);
ngx_int_t ngx_ssl_keyless_test_connect(ngx_connection_t *c);
void ngx_ssl_keyless_close_connection(ngx_connection_t *c);
void ngx_ssl_keyless_error(ngx_ssl_keyless_connection_t *skc);
void ngx_ssl_keyless_save_session(ngx_ssl_keyless_connection_t *skc,
    ngx_ssl_session_t **session);
ngx_int_t ngx_ssl_keyless_set_session(ngx_ssl_keyless_connection_t *skc,
    ngx_ssl_session_t *session);
void ngx_ssl_keyless_rd_check_broken_connection(ngx_event_t *ev);
void ngx_ssl_keyless_wr_check_broken_connection(ngx_event_t *ev);
void ngx_ssl_keyless_finalize_connection(ngx_connection_t *c);
int ngx_http_ssl_cert_callback(SSL *s, void *arg);
#endif

#if (NGX_KEYLESS_SSL || NGX_KEYLESS_SERVER)
void ngx_ssl_keyless_get_modulus_digest(RSA *key, uint8_t *digest);
void ngx_ssl_keyless_get_modulus_ec_digest(const EC_POINT *key, uint8_t *digest);
#endif


extern ngx_module_t ngx_openssl_module;

extern int  ngx_ssl_connection_index;
extern int  ngx_ssl_server_conf_index;
extern int  ngx_ssl_session_cache_index;
extern int  ngx_ssl_session_ticket_keys_index;
extern int  ngx_ssl_certificate_index;
extern int  ngx_ssl_next_certificate_index;
extern int  ngx_ssl_certificate_name_index;
extern int  ngx_ssl_stapling_index;


#if (OPENSSL_VERSION_NUMBER < 0x00904000)
#define ngx_ssl_pem_read_bio_x509(b, x, cb, arg)    \
    PEM_read_bio_X509(b, x, cb)
#else
#define ngx_ssl_pem_read_bio_x509(b, x, cb, arg)    \
    PEM_read_bio_X509(b, x, cb, arg)
#endif

#if (NGX_KEYLESS_SERVER)
typedef struct {
    ngx_atomic_t  requests;
    ngx_atomic_t  failed_requests;
    ngx_atomic_t  rt;
    ngx_atomic_t  nokey;
    ngx_atomic_t  badop;
    ngx_atomic_t  format;
    ngx_atomic_t  internal;
    ngx_atomic_t  decrypt;
    ngx_atomic_t  sign;
    ngx_atomic_t  conn;
    ngx_atomic_t  c_close;
    ngx_atomic_t  rtimeout;
    ngx_atomic_t  wtimeout;
} ngx_ssl_keyless_server_status_t;

typedef ngx_int_t
(*ngx_ssl_keyless_server_status_handler_pt)(ngx_ssl_keyless_server_status_t *stats);
extern ngx_ssl_keyless_server_status_handler_pt ngx_ssl_keyless_server_status;

typedef ngx_chain_t *
(*ngx_ssl_keyless_server_dump_handler_pt)(ngx_str_t id, ngx_pool_t *pool);
extern ngx_ssl_keyless_server_dump_handler_pt ngx_ssl_keyless_server_dump;
#endif

/*
 * Keyless SSL related stuff
 *
 */
#define KSSL_VERSION_MAJ    0x01
#define KSSL_VERSION_MIN    0x00

#define KSSL_TAG_DIGEST     0x01
#define KSSL_TAG_SNI        0x02
#define KSSL_TAG_CLIENT_IP  0x03
#define KSSL_TAG_RSA_PSS    0x05
#define KSSL_TAG_OPCODE     0x11
#define KSSL_TAG_PAYLOAD    0x12

#define KSSL_TAG_SERVER_IPPORT  0x13
#define KSSL_TAG_SLB_LBID 0x14
#define KSSL_TAG_SLB_VIPPORT 0x15
#define KSSL_TAG_SLB_SRVPID 0x16
#define KSSL_TAG_SLB_SRVCID 0x17

#define KSSL_TAG_PADDING    0x20

#define KSSL_PAD_TO 1024

#if (NGX_HAVE_PACK_PRAGMA)
#pragma pack(push, 1)
#elif (NGX_SOLARIS)
#pragma pack(1)
#else
#error "keyless SSL needs structure packing pragma support"
#endif

typedef struct {
  uint8_t  version_maj;
  uint8_t  version_min;
  uint16_t length;
  uint32_t id;
} kssl_header;

typedef struct {
  uint8_t  tag;
  uint16_t length;
} kssl_item;

#if (NGX_HAVE_PACK_PRAGMA)
#pragma pack(pop)
#elif (NGX_SOLARIS)
#pragma pack()
#else
#error "keyless SSL needs structure packing pragma support"
#endif

#define KSSL_OP_PING 0xF1
#define KSSL_OP_PONG 0xF2

#define KSSL_OP_RSA_DECRYPT               0x01

#define KSSL_OP_RSA_SIGN_MD5SHA1          0x02
#define KSSL_OP_RSA_SIGN_SHA1             0x03
#define KSSL_OP_RSA_SIGN_SHA224           0x04
#define KSSL_OP_RSA_SIGN_SHA256           0x05
#define KSSL_OP_RSA_SIGN_SHA384           0x06
#define KSSL_OP_RSA_SIGN_SHA512           0x07

#define KSSL_OP_ECC_DECRYPT               0x08
#define KSSL_OP_ECC_DECRYPT_FORMATED      0x09
#define KSSL_OP_ECC_SIGN                  0x0A

#define KSSL_OP_RESPONSE             0xF0
#define KSSL_OP_ERROR                0xFF

typedef enum {
  KSSL_ERROR_NONE              = 0x00,
  KSSL_ERROR_CRYPTO_FAILED     = 0x01,
  KSSL_ERROR_KEY_NOT_FOUND     = 0x02,
  KSSL_ERROR_READ_TIMEOUT      = 0x03,
  KSSL_ERROR_VERSION_MISMATCH  = 0x04,
  KSSL_ERROR_BAD_OPCODE        = 0x05,
  KSSL_ERROR_UNEXPECTED_OPCODE = 0x06,
  KSSL_ERROR_FORMAT            = 0x07,
  KSSL_ERROR_INTERNAL          = 0x08,
  KSSL_ERROR_DECRYPT_FAILED    = 0x09,
  KSSL_ERROR_SIGN_FAILED       = 0x0a,
  KSSL_ERROR_CONN_FAILED       = 0x0b,
  KSSL_ERROR_WRITE_TIMEOUT     = 0x0c,
  KSSL_ERROR_CLIENT_CLOSE      = 0x0d,
  KSSL_ERROR_REFUSE_HEALTH     = 0x0e
} kssl_error_code;


#endif /* _NGX_EVENT_OPENSSL_H_INCLUDED_ */
